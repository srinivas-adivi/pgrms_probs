import lib
import constants
from permutation import next_big
import prime


def problem20(n):
    """    
    >>> problem20(100)
    648
    """
    value = lib.factorial(n)
    return sum(lib.digits(value))

def problem21(m, n):
    """
    >>> problem21(2, 10000)
    31626
    """
    return sum([i for i in range(m, n) if lib.is_amicable(i)])

def problem22(filename):
    """
    >>> problem22('problem22.txt')
    871198282
    """
    text = open(filename).read()
    names = text.split(',')
    names.sort()
    names_index = range(len(names))
    return sum([(i+1) * sum([constants.alphabets.index(letter)+1\
                            for letter in names[i].strip('"')])\
                                for i in names_index])

def problem23():
    """
    >>> problem23()
    4179871
    """
    abundans, flags = [], [1]*constants.abundan_limit
    for n in range(1, constants.abundan_limit+1):
        if lib.is_abundan(n):
            try:
                for a in abundans:
                    flags[a+n] = 0

                flags[2*n] = 0
            except IndexError, e:
                #i.e a+n or 2*n > abundan_limit hence ignore
                pass
            abundans.append(n)
    
    non_abundans = [i*flag for i, flag in enumerate(flags)]

    return sum(non_abundans)

def problem24():
    """
    >>> problem24()
    2783915460
    """
    n = '0123456789'
    i = 1
    while i<1000000:
        n = next_big(n)
        i = i+1
    return int(n) 

def problem25(n):
    """
    >>> problem25(1000)
    4782
    """
    fib_nums = [1, 1]
    next_fib = fib_nums[-1]+fib_nums[-2]
    while len(str(next_fib)) < n:
        fib_nums.append(next_fib)
        next_fib = fib_nums[-1] + fib_nums[-2]
    return len(fib_nums)+1
     
def problem26():
    """http://projecteuler.net/index.php?section=problems&id=26
    >>> problem26()
    983
    """
    L = range(2, 1000)
    result = []
    for n in L:
        remainders = [1]
        divident = 10
        while divident:
            if divident < n:
                #remainders.append(divident)
                divident = divident * 10
            else:
                quoient, divident = divmod(divident, n)
                if divident in remainders:
                    index = remainders.index(divident)
                    result.append((n, len(remainders)- index))
                    break
                else:
                    remainders.append(divident)
    result.sort(key=lambda (n, c): c)

    return result[-1][0]
    
def problem27():
    """http://projecteuler.net/index.php?section=problems&id=27
    >>> problem27()
    -59231
    """
    max_pair = (0,0,0)
    primes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47]
    for a in xrange(-999, 1000):
        for b in xrange(max(2, 1-a), 1000): # b >= 2, a + b + 1 >= 2
            n, count = 0, 0
            while True:
                v = n*n + a*n + b
                v = v <=0 and -v or v
                if v > primes[-1]:
                    prime.primesBelow_fast(v, primes)
                    if prime.isprime_fast(v, primes): count = count + 1
                    else: break
                else:
                    if not prime.hasFactors(v, primes): count = count + 1
                    else: break
                n = n + 1
            if count > max_pair[2]:
                max_pair = (a,b,count)
    return max_pair[0] * max_pair[1]

def problem28_old(n):
    """
    >>> problem28_old(1001)
    669171001
    """
    result, sum1= 1,1
    for count in range(2, n, 2):
        sum2 = 0
        for count1 in range(1,5):
            temp = count * count1
            sum2 = sum2 + sum1 + temp
        sum1 = sum1 + temp
        result = result + sum2
    return result
    
def problem28(n):
    """ return sum of both diagonals in n by n spiral
    >>> problem28(1001)
    669171001
    >>> problem28(5)
    101
    >>> problem28(3)
    25
    """
    mod = n%2
    result = sum(map(lib.sum_conners_N_spiral, range(mod, n+1, 2)))
    return result

def problem29_old():
    """
    >>> problem29_old()
    9183
    """
    l = [a**b for a in range(2,101) for b in range(2,101)]
    return len(set(l))

def problem29(a, b):
    """ return no.of distinct terms in the sequence generated by a power b for 
        2 <= a <= 100 and 2 <= b <= 100?
    >>> problem29(2, 101)
    9183
    """
    L = range(a, b)
    result = len(set([lib.power(x, y) for x in L for y in L]))
    return result


if __name__ == "__main__":
    import doctest
    doctest.testmod()
